{"schema":{"type":"object","required":["astroport_factory_execute_msg"],"properties":{"astroport_factory_execute_msg":{"title":"astroport_factory_execute_msg","description":"This structure describes the execute messages of the contract.","oneOf":[{"description":"UpdateConfig updates relevant code IDs","type":"object","required":["update_config"],"properties":{"update_config":{"type":"object","properties":{"fee_address":{"description":"contract address to send fees to","type":["string","null"]},"generator_address":{"description":"contract address that used for auto_stake from pools","type":["string","null"]},"token_code_id":{"description":"CW20 token contract code identifier","type":["integer","null"],"format":"uint64","minimum":0}}}},"additionalProperties":false},{"description":"UpdatePairConfig updates configs of pair","type":"object","required":["update_pair_config"],"properties":{"update_pair_config":{"type":"object","required":["config"],"properties":{"config":{"description":"new [`PairConfig`] settings for pair","allOf":[{"title":"Description","description":"This structure describes a configuration of pair.","type":"object","required":["code_id","maker_fee_bps","pair_type","total_fee_bps"],"properties":{"code_id":{"description":"pair contract code ID which are allowed to create pair","type":"integer","format":"uint64","minimum":0},"is_disabled":{"description":"We disable pair configs instead of removing them. If it is disabled, new pairs cannot be created, but existing ones can still obtain proper settings, such as fee amounts","type":["boolean","null"]},"maker_fee_bps":{"description":"a pair fees bps","type":"integer","format":"uint16","minimum":0},"pair_type":{"description":"the type of pair available in [`PairType`]","allOf":[{"title":"Description","description":"This enum describes available types of pair. ## Available types ``` # use astroport::factory::PairType::{Custom, Stable, Xyk}; Xyk {}; Stable {}; Custom(String::from(\"Custom\")); ```","oneOf":[{"description":"XYK pair type","type":"object","required":["xyk"],"properties":{"xyk":{"type":"object"}},"additionalProperties":false},{"description":"Stable pair type","type":"object","required":["stable"],"properties":{"stable":{"type":"object"}},"additionalProperties":false},{"description":"Custom pair type","type":"object","required":["custom"],"properties":{"custom":{"type":"string"}},"additionalProperties":false}]}]},"total_fee_bps":{"description":"a pair total fees bps","type":"integer","format":"uint16","minimum":0}}}]}}}},"additionalProperties":false},{"description":"CreatePair instantiates pair contract","type":"object","required":["create_pair"],"properties":{"create_pair":{"type":"object","required":["asset_infos","pair_type"],"properties":{"asset_infos":{"description":"the type of asset infos available in [`AssetInfo`]","type":"array","items":{"title":"Description","description":"This enum describes available types of Token. ## Examples ``` # use cosmwasm_std::Addr; # use astroport::asset::AssetInfo::{NativeToken, Token}; Token { contract_addr: Addr::unchecked(\"terra...\") }; NativeToken { denom: String::from(\"uluna\") }; ```","oneOf":[{"description":"Token","type":"object","required":["token"],"properties":{"token":{"type":"object","required":["contract_addr"],"properties":{"contract_addr":{"description":"A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.","type":"string"}}}},"additionalProperties":false},{"description":"Native token","type":"object","required":["native_token"],"properties":{"native_token":{"type":"object","required":["denom"],"properties":{"denom":{"type":"string"}}}},"additionalProperties":false}]},"maxItems":2,"minItems":2},"init_params":{"description":"Optional binary serialised parameters for custom pool types","anyOf":[{"description":"Binary is a wrapper around Vec<u8> to add base64 de/serialization with serde. It also adds some helper methods to help encode inline.\n\nThis is only needed as serde-json-{core,wasm} has a horrible encoding for Vec<u8>","type":"string"},{"type":"null"}]},"pair_type":{"description":"the type of pair available in [`PairType`]","allOf":[{"title":"Description","description":"This enum describes available types of pair. ## Available types ``` # use astroport::factory::PairType::{Custom, Stable, Xyk}; Xyk {}; Stable {}; Custom(String::from(\"Custom\")); ```","oneOf":[{"description":"XYK pair type","type":"object","required":["xyk"],"properties":{"xyk":{"type":"object"}},"additionalProperties":false},{"description":"Stable pair type","type":"object","required":["stable"],"properties":{"stable":{"type":"object"}},"additionalProperties":false},{"description":"Custom pair type","type":"object","required":["custom"],"properties":{"custom":{"type":"string"}},"additionalProperties":false}]}]}}}},"additionalProperties":false},{"description":"Deregister removes a previously created pair","type":"object","required":["deregister"],"properties":{"deregister":{"type":"object","required":["asset_infos"],"properties":{"asset_infos":{"description":"the type of asset infos available in [`AssetInfo`]","type":"array","items":{"title":"Description","description":"This enum describes available types of Token. ## Examples ``` # use cosmwasm_std::Addr; # use astroport::asset::AssetInfo::{NativeToken, Token}; Token { contract_addr: Addr::unchecked(\"terra...\") }; NativeToken { denom: String::from(\"uluna\") }; ```","oneOf":[{"description":"Token","type":"object","required":["token"],"properties":{"token":{"type":"object","required":["contract_addr"],"properties":{"contract_addr":{"description":"A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.","type":"string"}}}},"additionalProperties":false},{"description":"Native token","type":"object","required":["native_token"],"properties":{"native_token":{"type":"object","required":["denom"],"properties":{"denom":{"type":"string"}}}},"additionalProperties":false}]},"maxItems":2,"minItems":2}}}},"additionalProperties":false},{"description":"ProposeNewOwner creates an offer for a new owner. The validity period of the offer is set in the `expires_in` variable.","type":"object","required":["propose_new_owner"],"properties":{"propose_new_owner":{"type":"object","required":["expires_in","owner"],"properties":{"expires_in":{"description":"the offer expiration date for the new owner","type":"integer","format":"uint64","minimum":0},"owner":{"description":"contract address that used for controls settings for factory, pools and tokenomics contracts","type":"string"}}}},"additionalProperties":false},{"description":"DropOwnershipProposal removes the existing offer for the new owner.","type":"object","required":["drop_ownership_proposal"],"properties":{"drop_ownership_proposal":{"type":"object"}},"additionalProperties":false},{"description":"Used to claim(approve) new owner proposal, thus changing contract's owner","type":"object","required":["claim_ownership"],"properties":{"claim_ownership":{"type":"object"}},"additionalProperties":false}]}},"additionalProperties":false},"ui-schema":{},"form-data":{}}