{"schema":{"type":"object","required":["extension"],"properties":{"extension":{"type":"object","required":["msg"],"properties":{"msg":{"oneOf":[{"type":"object","required":["andr_query"],"properties":{"andr_query":{"oneOf":[{"type":"object","required":["get"],"properties":{"get":{"anyOf":[{"description":"Binary is a wrapper around Vec<u8> to add base64 de/serialization with serde. It also adds some helper methods to help encode inline.\n\nThis is only needed as serde-json-{core,wasm} has a horrible encoding for Vec<u8>. See also <https://github.com/CosmWasm/cosmwasm/blob/main/docs/MESSAGE_TYPES.md>.","type":"string","$original_type":"Binary"},{"type":"null"}]}},"additionalProperties":false},{"type":"object","required":["owner"],"properties":{"owner":{"type":"object","additionalProperties":false}},"additionalProperties":false},{"type":"object","required":["operators"],"properties":{"operators":{"type":"object","additionalProperties":false}},"additionalProperties":false},{"type":"object","required":["type"],"properties":{"type":{"type":"object","additionalProperties":false}},"additionalProperties":false},{"type":"object","required":["original_publisher"],"properties":{"original_publisher":{"type":"object","additionalProperties":false}},"additionalProperties":false},{"type":"object","required":["block_height_upon_creation"],"properties":{"block_height_upon_creation":{"type":"object","additionalProperties":false}},"additionalProperties":false},{"type":"object","required":["is_operator"],"properties":{"is_operator":{"type":"object","required":["address"],"properties":{"address":{"type":"string"}},"additionalProperties":false}},"additionalProperties":false},{"type":"object","required":["module"],"properties":{"module":{"type":"object","required":["id"],"properties":{"id":{"description":"A thin wrapper around u64 that is using strings for JSON encoding/decoding, such that the full u64 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u64` to get the value out:\n\n``` # use cosmwasm_std::Uint64; let a = Uint64::from(42u64); assert_eq!(a.u64(), 42);\n\nlet b = Uint64::from(70u32); assert_eq!(b.u64(), 70); ```","type":"string","$original_type":"Uint64"}},"additionalProperties":false}},"additionalProperties":false},{"type":"object","required":["module_ids"],"properties":{"module_ids":{"type":"object","additionalProperties":false}},"additionalProperties":false},{"type":"object","required":["version"],"properties":{"version":{"type":"object","additionalProperties":false}},"additionalProperties":false}],"$original_type":"AndromedaQuery"}},"additionalProperties":false},{"type":"object","required":["andr_hook"],"properties":{"andr_hook":{"oneOf":[{"type":"object","required":["on_execute"],"properties":{"on_execute":{"type":"object","required":["payload","sender"],"properties":{"payload":{"description":"Binary is a wrapper around Vec<u8> to add base64 de/serialization with serde. It also adds some helper methods to help encode inline.\n\nThis is only needed as serde-json-{core,wasm} has a horrible encoding for Vec<u8>. See also <https://github.com/CosmWasm/cosmwasm/blob/main/docs/MESSAGE_TYPES.md>.","type":"string","$original_type":"Binary"},"sender":{"type":"string"}},"additionalProperties":false}},"additionalProperties":false},{"type":"object","required":["on_funds_transfer"],"properties":{"on_funds_transfer":{"type":"object","required":["amount","payload","sender"],"properties":{"amount":{"oneOf":[{"type":"object","required":["native"],"properties":{"native":{"type":"object","required":["amount","denom"],"properties":{"amount":{"description":"A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```","type":"string","$original_type":"Uint128"},"denom":{"type":"string"}},"$original_type":"Coin"}},"additionalProperties":false},{"type":"object","required":["cw20"],"properties":{"cw20":{"type":"object","required":["address","amount"],"properties":{"address":{"type":"string"},"amount":{"description":"A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```","type":"string","$original_type":"Uint128"}},"additionalProperties":false,"$original_type":"Cw20Coin"}},"additionalProperties":false}],"$original_type":"Funds"},"payload":{"description":"Binary is a wrapper around Vec<u8> to add base64 de/serialization with serde. It also adds some helper methods to help encode inline.\n\nThis is only needed as serde-json-{core,wasm} has a horrible encoding for Vec<u8>. See also <https://github.com/CosmWasm/cosmwasm/blob/main/docs/MESSAGE_TYPES.md>.","type":"string","$original_type":"Binary"},"sender":{"type":"string"}},"additionalProperties":false}},"additionalProperties":false},{"type":"object","required":["on_transfer"],"properties":{"on_transfer":{"type":"object","required":["recipient","sender","token_id"],"properties":{"recipient":{"type":"string"},"sender":{"type":"string"},"token_id":{"type":"string"}},"additionalProperties":false}},"additionalProperties":false}],"$original_type":"AndromedaHook"}},"additionalProperties":false},{"description":"Owner of the given token by ID","type":"object","required":["owner_of"],"properties":{"owner_of":{"type":"object","required":["token_id"],"properties":{"include_expired":{"type":["boolean","null"]},"token_id":{"type":"string"}},"additionalProperties":false}},"additionalProperties":false},{"description":"Approvals for a given address (paginated)","type":"object","required":["all_operators"],"properties":{"all_operators":{"type":"object","required":["owner"],"properties":{"include_expired":{"type":["boolean","null"]},"limit":{"type":["integer","null"],"format":"uint32","minimum":0},"owner":{"type":"string"},"start_after":{"type":["string","null"]}},"additionalProperties":false}},"additionalProperties":false},{"description":"Amount of tokens minted by the contract","type":"object","required":["num_tokens"],"properties":{"num_tokens":{"type":"object","additionalProperties":false}},"additionalProperties":false},{"description":"The data of a token","type":"object","required":["nft_info"],"properties":{"nft_info":{"type":"object","required":["token_id"],"properties":{"token_id":{"type":"string"}},"additionalProperties":false}},"additionalProperties":false},{"description":"The data of a token and any approvals assigned to it","type":"object","required":["all_nft_info"],"properties":{"all_nft_info":{"type":"object","required":["token_id"],"properties":{"include_expired":{"type":["boolean","null"]},"token_id":{"type":"string"}},"additionalProperties":false}},"additionalProperties":false},{"description":"All tokens minted by the contract owned by a given address (paginated)","type":"object","required":["tokens"],"properties":{"tokens":{"type":"object","required":["owner"],"properties":{"limit":{"type":["integer","null"],"format":"uint32","minimum":0},"owner":{"type":"string"},"start_after":{"type":["string","null"]}},"additionalProperties":false}},"additionalProperties":false},{"description":"All tokens minted by the contract (paginated)","type":"object","required":["all_tokens"],"properties":{"all_tokens":{"type":"object","properties":{"limit":{"type":["integer","null"],"format":"uint32","minimum":0},"start_after":{"type":["string","null"]}},"additionalProperties":false}},"additionalProperties":false},{"description":"If the token is archived","type":"object","required":["is_archived"],"properties":{"is_archived":{"type":"object","required":["token_id"],"properties":{"token_id":{"type":"string"}},"additionalProperties":false}},"additionalProperties":false},{"description":"The transfer agreement for the token","type":"object","required":["transfer_agreement"],"properties":{"transfer_agreement":{"type":"object","required":["token_id"],"properties":{"token_id":{"type":"string"}},"additionalProperties":false}},"additionalProperties":false},{"description":"The current config of the contract","type":"object","required":["contract_info"],"properties":{"contract_info":{"type":"object","additionalProperties":false}},"additionalProperties":false},{"type":"object","required":["extension"],"properties":{"extension":{"type":"object","required":["msg"],"properties":{"msg":"SELF"},"additionalProperties":false}},"additionalProperties":false},{"type":"object","required":["minter"],"properties":{"minter":{"type":"object","additionalProperties":false}},"additionalProperties":false},{"type":"object","required":["approval"],"properties":{"approval":{"type":"object","required":["spender","token_id"],"properties":{"include_expired":{"type":["boolean","null"]},"spender":{"type":"string"},"token_id":{"type":"string"}},"additionalProperties":false}},"additionalProperties":false},{"description":"Return approvals that a token has Return type: `ApprovalsResponse`","type":"object","required":["approvals"],"properties":{"approvals":{"type":"object","required":["token_id"],"properties":{"include_expired":{"type":["boolean","null"]},"token_id":{"type":"string"}},"additionalProperties":false}},"additionalProperties":false}],"$original_type":"QueryMsg","title":"Msg"}},"additionalProperties":false,"title":"Extension"}},"additionalProperties":false,"title":"Extension","$id":"extension","class":"query","version":"0.1.1","classifier":""},"ui-schema":{},"form-data":{}}