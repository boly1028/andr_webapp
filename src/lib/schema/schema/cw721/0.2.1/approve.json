{
  "schema": {
    "description": "Allows operator to transfer / send the token from the owner's account. If expiration is set, then this allowance has a time/height limit",
    "type": "object",
    "required": ["approve"],
    "properties": {
      "approve": {
        "type": "object",
        "required": ["spender", "token_id"],
        "properties": {
          "expires": {
            "anyOf": [
              {
                "description": "Expiration represents a point in time when some event happens. It can compare with a BlockInfo and will return is_expired() == true once the condition is hit (and for every block in the future)",
                "oneOf": [
                  {
                    "description": "AtHeight will expire when `env.block.height` >= height",
                    "type": "object",
                    "required": ["at_height"],
                    "properties": {
                      "at_height": {
                        "type": "integer",
                        "format": "uint64",
                        "minimum": 0
                      }
                    },
                    "additionalProperties": false
                  },
                  {
                    "description": "AtTime will expire when `env.block.time` >= time",
                    "type": "object",
                    "required": ["at_time"],
                    "properties": {
                      "at_time": {
                        "description": "A point in time in nanosecond precision.\n\nThis type can represent times from 1970-01-01T00:00:00Z to 2554-07-21T23:34:33Z.\n\n## Examples\n\n``` # use cosmwasm_std::Timestamp; let ts = Timestamp::from_nanos(1_000_000_202); assert_eq!(ts.nanos(), 1_000_000_202); assert_eq!(ts.seconds(), 1); assert_eq!(ts.subsec_nanos(), 202);\n\nlet ts = ts.plus_seconds(2); assert_eq!(ts.nanos(), 3_000_000_202); assert_eq!(ts.seconds(), 3); assert_eq!(ts.subsec_nanos(), 202); ```",
                        "allOf": [
                          {
                            "description": "A thin wrapper around u64 that is using strings for JSON encoding/decoding, such that the full u64 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u64` to get the value out:\n\n``` # use cosmwasm_std::Uint64; let a = Uint64::from(42u64); assert_eq!(a.u64(), 42);\n\nlet b = Uint64::from(70u32); assert_eq!(b.u64(), 70); ```",
                            "type": "string",
                            "$original_type": "Uint64"
                          }
                        ],
                        "$original_type": "Timestamp"
                      }
                    },
                    "additionalProperties": false
                  },
                  {
                    "description": "Never will never expire. Used to express the empty variant",
                    "type": "object",
                    "required": ["never"],
                    "properties": {
                      "never": {
                        "type": "object",
                        "additionalProperties": false
                      }
                    },
                    "additionalProperties": false
                  }
                ],
                "$original_type": "Expiration"
              },
              { "type": "null" }
            ],
            "title": "Expires"
          },
          "spender": { "type": "string", "title": "Spender" },
          "token_id": { "type": "string", "title": "Token id" }
        },
        "additionalProperties": false,
        "title": "Approve"
      }
    },
    "additionalProperties": false,
    "title": "Approve",
    "$id": "approve",
    "class": "modifier",
    "version": "0.2.1",
    "classifier": ""
  },
  "ui-schema": {},
  "form-data": {}
}
