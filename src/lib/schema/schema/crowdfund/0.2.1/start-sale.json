{
  "schema": {
    "description": "Starts the sale if one is not already ongoing.",
    "type": "object",
    "required": ["start_sale"],
    "properties": {
      "start_sale": {
        "type": "object",
        "required": ["expiration", "min_tokens_sold", "price", "recipient"],
        "properties": {
          "expiration": {
            "description": "When the sale ends.",
            "allOf": [
              {
                "description": "Expiration represents a point in time when some event happens. It can compare with a BlockInfo and will return is_expired() == true once the condition is hit (and for every block in the future)",
                "oneOf": [
                  {
                    "type": "object",
                    "required": ["at_height"],
                    "properties": {
                      "at_height": {
                        "type": "integer",
                        "format": "uint64",
                        "minimum": 0
                      }
                    },
                    "additionalProperties": false
                  },
                  {
                    "type": "object",
                    "required": ["at_time"],
                    "properties": {
                      "at_time": {
                        "description": "A point in time in nanosecond precision.\n\nThis type can represent times from 1970-01-01T00:00:00Z to 2554-07-21T23:34:33Z.\n\n## Examples\n\n``` # use cosmwasm_std::Timestamp; let ts = Timestamp::from_nanos(1_000_000_202); assert_eq!(ts.nanos(), 1_000_000_202); assert_eq!(ts.seconds(), 1); assert_eq!(ts.subsec_nanos(), 202);\n\nlet ts = ts.plus_seconds(2); assert_eq!(ts.nanos(), 3_000_000_202); assert_eq!(ts.seconds(), 3); assert_eq!(ts.subsec_nanos(), 202); ```",
                        "type": "string",
                        "$original_type": "Timestamp"
                      }
                    },
                    "additionalProperties": false
                  },
                  {
                    "type": "object",
                    "required": ["never"],
                    "properties": {
                      "never": {
                        "type": "object",
                        "additionalProperties": false
                      }
                    },
                    "additionalProperties": false
                  }
                ],
                "$original_type": "Expiration"
              }
            ],
            "title": "Expiration"
          },
          "max_amount_per_wallet": {
            "description": "The amount of tokens a wallet can purchase, default is 1.",
            "type": ["integer", "null"],
            "format": "uint32",
            "minimum": 0,
            "title": "Max amount per wallet"
          },
          "min_tokens_sold": {
            "description": "The minimum amount of tokens sold to go through with the sale.",
            "allOf": [
              {
                "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
                "type": "string",
                "$original_type": "Uint128"
              }
            ],
            "title": "Min tokens sold"
          },
          "price": {
            "description": "The price per token.",
            "allOf": [
              {
                "type": "object",
                "required": ["amount", "denom"],
                "properties": {
                  "amount": {
                    "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
                    "type": "string",
                    "$original_type": "Uint128"
                  },
                  "denom": { "type": "string" }
                },
                "$original_type": "Coin"
              }
            ],
            "title": "Price"
          },
          "recipient": {
            "description": "The recipient of the funds if the sale met the minimum sold.",
            "allOf": [
              {
                "description": "A simple struct used for inter-contract communication. The struct can be used in two ways:\n\n1. Simply just providing an `AndrAddr` which will treat the communication as a transfer of any related funds 2. Providing an `AndrAddr` and a `Binary` message which will be sent to the contract at the resolved address\n\nThe `Binary` message can be any message that the contract at the resolved address can handle.",
                "type": "object",
                "required": ["address"],
                "properties": {
                  "address": {
                    "description": "An address that can be used within the Andromeda ecosystem. Inspired by the cosmwasm-std `Addr` type. https://github.com/CosmWasm/cosmwasm/blob/2a1c698520a1aacedfe3f4803b0d7d653892217a/packages/std/src/addresses.rs#L33\n\nThis address can be one of two things: 1. A valid human readable address e.g. `cosmos1...` 2. A valid Andromeda VFS path e.g. `/home/user/app/component`\n\nVFS paths can be local in the case of an app and can be done by referencing `./component` they can also contain protocols for cross chain communication. A VFS path is usually structured as so:\n\n`<protocol>://<chain (required if ibc used)>/<path>` or `ibc://cosmoshub-4/user/app/component`",
                    "type": "string",
                    "$original_type": "AndrAddr"
                  },
                  "ibc_recovery_address": {
                    "anyOf": [
                      {
                        "description": "An address that can be used within the Andromeda ecosystem. ",
                        "type": "string",
                        "$original_type": "AndrAddr"
                      },
                      { "type": "null" }
                    ]
                  },
                  "msg": {
                    "anyOf": [
                      {
                        "description": "Binary is a wrapper around Vec<u8> to add base64 de/serialization with serde. It also adds some helper methods to help encode inline.\n\nThis is only needed as serde-json-{core,wasm} has a horrible encoding for Vec<u8>. See also <https://github.com/CosmWasm/cosmwasm/blob/main/docs/MESSAGE_TYPES.md>.",
                        "type": "string",
                        "$original_type": "Binary"
                      },
                      { "type": "null" }
                    ]
                  }
                },
                "additionalProperties": false,
                "$original_type": "Recipient"
              }
            ],
            "title": "Recipient"
          }
        },
        "additionalProperties": false,
        "title": "Start sale"
      }
    },
    "additionalProperties": false,
    "title": "Start Sale",
    "$id": "start-sale",
    "class": "modifier",
    "version": "0.2.1",
    "classifier": ""
  },
  "ui-schema": {
    "start_sale": {
      "ui:options": {
        "title": "Start Sale",
        "description": "",
        "alerts": [
          { "text": "Only available to the contract owner.", "type": "error" }
        ]
      },
      "expiration": {
        "ui:options": {
          "optionNames": ["At Height", "At Time", "Never"],
          "title": "Expiration"
        },
        "at_height": {
          "ui:options": {
            "title": "Expire Height",
            "description": "The block height to reach.",
            "help": "Numeric value, such as '1000'",
            "alerts": [
              {
                "text": "AtHeight will expire when `env.block.height` >= height",
                "type": "info"
              }
            ]
          }
        },
        "at_time": {
          "ui:options": {
            "title": "Expire Time",
            "description": "A point in time declared in nanosecond.",
            "alerts": [
              {
                "text": "AtTime will expire when env.block.time >= time.",
                "type": "info"
              }
            ]
          },
          "ui:widget": "nanodateTime"
        },
        "never": {
          "ui:options": {
            "title": "Never",
            "description": "Never will never expire. Used to express the empty variant."
          }
        }
      },
      "max_amount_per_wallet": {
        "ui:options": {
          "title": "Max Tokens Per Wallet",
          "description": "The amount of tokens a wallet can purchase.",
          "help": "Default is 1",
          "placeholder": "e.g., 5"
        }
      },
      "min_tokens_sold": {
        "ui:options": {
          "title": "Minimum Tokens Being Sold",
          "description": "The minimum number of tokens required to be sold.",
          "placeholder": "e.g., 100"
        }
      },
      "price": {
        "ui:options": {
          "title": "Price Per Token/NFT",
          "description": "The price per token.",
          "placeholder": "e.g., 2.50"
        },
        "amount": {
          "ui:options": {
            "title": "Amount",
            "description": "The amount of funds.",
            "placeholder": "e.g., 1000"
          }
        },
        "denom": {
          "ui:options": {
            "title": "Denomination",
            "description": "The denomination of the funds.",
            "placeholder": "e.g., uandr"
          }
        }
      },      
      "recipient": {
        "ui:options": {
          "title": "Recipient",
          "description": "The recipient of the funds if the sale has met the minimum sell goal."
        },
        "addr": { "ui:options": { "title": "Address" } },
        "address": {
          "ui:options": {
            "title": "Address",
            "description": "Addr can also be a human-readable identifier used in a app contract.",
            "placeholder": "e.g., andr1fl48v...0eh or ./componentName"
          },
          "identifier": {
            "ui:options": {
              "description": "Can be either an address or app component name of a specific ADO within an app",
              "title": "Identifier"
            }
          }
        },
        "ibc_recovery_address": {
          "ui:options": {
            "optionNames": ["Declared", "None"],
            "title": "IBC Recovery Address",
            "description": "(Optional) Choose an address to recover funds in the case of a failed IBC transfer.",
            "placeholder": "e.g., andr1fl48v...0eh or ./componentName",
            "alerts": [
              {
                "text": "This address will be used to recover funds in the case of a failed IBC transfer.",
                "type": "info"
              }
            ]
          }
        },
        "msg": {
          "ui:options": {
            "optionNames": ["Attached", "None"],
            "title": "Message",
            "description": "A message to send to the contract at the resolved address."
          }
        }
      }
    }
  },
  "form-data": {}
}
